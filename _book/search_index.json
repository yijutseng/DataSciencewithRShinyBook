[
["index.html", "使用R Shiny設計資料科學應用程式", " 使用R Shiny設計資料科學應用程式 曾意儒 Yi-Ju Tseng 2020-04-07 本書介如何使用R語言以及Shiny App開發資料科學相關的網頁應用程式，包括互動式圖表、儀表板、互動式資料分析服務等，大部分內容由RStudio官方教學與Shiny文件統整翻譯而成。 本書仍在草稿撰寫階段，已完成第1至5章，後續章節逐步更新中。 如要一次安裝所有本書會使用到的套件，可在R內執行以下程式碼： install.packages(&quot;devtools&quot;) devtools::install_github(&quot;yijutseng/DataSciencewithRShinyBook&quot;) 如果您想修改文字或範例，歡迎透過 GitHub issue提供建議與回饋。 本書程式碼執行環境： sessionInfo() ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS Catalina 10.15.3 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] leaflet_2.0.3 shinyloadtest_1.0.1 profvis_0.3.6 ## [4] shinydashboard_0.7.1 shinythemes_1.1.2 rsconnect_0.8.15 ## [7] shiny_1.4.0.2 forcats_0.4.0 stringr_1.4.0 ## [10] dplyr_0.8.3 purrr_0.3.3 readr_1.3.1 ## [13] tidyr_1.0.0 tibble_2.1.3 ggplot2_3.2.1 ## [16] tidyverse_1.3.0 ## ## loaded via a namespace (and not attached): ## [1] nlme_3.1-140 fs_1.3.1 sf_0.8-0 lubridate_1.7.4 ## [5] httr_1.4.1 tools_3.6.1 backports_1.1.5 R6_2.4.0 ## [9] KernSmooth_2.23-15 rgeos_0.5-2 DBI_1.0.0 lazyeval_0.2.2 ## [13] colorspace_1.4-1 withr_2.1.2 sp_1.3-1 tidyselect_0.2.5 ## [17] curl_4.2 compiler_3.6.1 cli_1.1.0 rvest_0.3.5 ## [21] xml2_1.2.2 bookdown_0.14 scales_1.0.0 classInt_0.4-2 ## [25] askpass_1.1 digest_0.6.21 foreign_0.8-71 rmarkdown_1.16 ## [29] pkgconfig_2.0.3 htmltools_0.4.0 dbplyr_1.4.2 fastmap_1.0.1 ## [33] highr_0.8 htmlwidgets_1.5.1 rlang_0.4.4 readxl_1.3.1 ## [37] rstudioapi_0.10 httpcode_0.2.0 generics_0.0.2 jsonlite_1.6 ## [41] crosstalk_1.0.0 magrittr_1.5 Rcpp_1.0.2 munsell_0.5.0 ## [45] lifecycle_0.1.0 stringi_1.4.3 yaml_2.2.0 jqr_1.1.0 ## [49] maptools_0.9-8 grid_3.6.1 promises_1.1.0 crayon_1.3.4 ## [53] geojsonio_0.9.0 lattice_0.20-38 haven_2.2.0 geojson_0.3.2 ## [57] hms_0.5.3 knitr_1.25 pillar_1.4.2 servr_0.15 ## [61] crul_0.9.0 reprex_0.3.0 glue_1.3.1 packrat_0.5.0 ## [65] evaluate_0.14 V8_3.0.2 modelr_0.1.6 png_0.1-7 ## [69] vctrs_0.2.3 httpuv_1.5.2 cellranger_1.1.0 openssl_1.4.1 ## [73] gtable_0.3.0 assertthat_0.2.1 xfun_0.10 mime_0.7 ## [77] xtable_1.8-4 broom_0.5.2 e1071_1.7-2 later_1.0.0 ## [81] class_7.3-15 units_0.6-5 本書使用套件版本： Package Version tidyverse 1.3.0 shiny 1.4.0.2 rsconnect 0.8.15 shinythemes 1.1.2 shinydashboard 0.7.1 profvis 0.3.6 shinyloadtest 1.0.1 本著作係採用創用 CC 姓名標示-非商業性-禁止改作 3.0 台灣 授權條款授權。 "],
["intro.html", "Ch 1 前言", " Ch 1 前言 Shiny App 是 RStudio推出供R語言使用的網頁應用框架（Web application framework），透過Shiny，使用者可以輕鬆地將資料分析結果轉換成互動式的網頁應用程式，簡單來說就是動態網站，如果不做客製化的使用者介面調整，不用另外學習其他網頁程式語言（如HTML, CSS, JavaScript等），若要使用Shiny， RStudio IDE提供完整測試預覽功能，建議一起使用。使用前必須先安裝並載入shiny package (Chang et al. 2020) install.packages(&quot;shiny&quot;) library(shiny) 安裝完成後，若想快速體驗Shiny App的效果，可執行下列程式碼，查看Shiny package內提供的11個網頁部署範例，以及參考範例相對應的原始碼： runExample(&quot;01_hello&quot;) # a histogram runExample(&quot;02_text&quot;) # tables and data frames runExample(&quot;03_reactivity&quot;) # a reactive expression runExample(&quot;04_mpg&quot;) # global variables runExample(&quot;05_sliders&quot;) # slider bars runExample(&quot;06_tabsets&quot;) # tabbed panels runExample(&quot;07_widgets&quot;) # help text and submit buttons runExample(&quot;08_html&quot;) # Shiny app built from HTML runExample(&quot;09_upload&quot;) # file upload wizard runExample(&quot;10_download&quot;) # file download wizard runExample(&quot;11_timer&quot;) # an automated timer 使開始資料分析專案類似，若有使用RStudio IDE，在開始建構Shiny App前建議先新增一個Shiny Project，建構方式可參考下方影片: 步驟如下: 點選Create a Project 依需求選擇需要開新資料夾或是使用原有資料夾 選擇Shiny Web Application Project 輸入Project name，也會同時是資料夾的名稱 完成新增Shiny Project，資料夾中會有一個app.R檔案，即為撰寫Shiny App前後端程式碼的地方 點選程式碼上方的Run，就會跑出經典的Shiny App範例程式 Run App所在位置： 經典的直方圖Shiny範例程式： 本書接下來的章節會針對Shiny App架構、前後端程式與元件、客製化設計、程式測試以及部屬上線等內容逐一介紹。 References "],
["structure.html", "Ch 2 Shiny App架構 2.1 單一整合程式 app.R 2.2 使用者介面 (User Interface) 2.3 伺服器端程式 (Server Instruction) 2.4 除了前後端以外的程式碼 2.5 參考資料", " Ch 2 Shiny App架構 Shiny App是由使用者介面(User Interface)與伺服器端程式 (Server Instruction)組合而成，分別負責下列功能： 使用者介面(User Interface) (前端)： 輸入元件： 讓使用者可依需求改變各項數值，如篩選閾值、分析項目選擇等（如只要分析50元以下的商品） 讓使用者觸發程式執行（如點選“計算”按鈕等） 輸出元件：呈現分析結果，可以用文字、圖、表或是地圖等方式呈現 伺服器端程式 (Server Instruction) (後端)：產出使用者介面所需的輸出元件 2.1 單一整合程式 app.R 在新增Shiny Project時，RStudio IDE會自動生成單一整合程式app.R，此程式碼的檔名是固定的，不能修改，內容包含與使用者介面(User Interface)相關的ui function、與伺服器端程式 (Server Instruction)相關的server function以及最後呼叫shinyApp()將ui與server組合成Shiny App，程式碼架構如下： ui &lt;- fluidPage( # 使用者介面 ) server &lt;- function (input,output){ # 伺服器端程式 } shinyApp(ui = ui, server = server) 若你不想建立R project，上述程式碼也可直接複製貼上至R Script，並將R Script的檔名設為app.R，點選程式碼編輯區上方的Run App，即可看到一空白網頁，表示Shiny可在你的電腦正常運作。未來若想建立任何新的Shiny App，可上述程式碼作為起點，並依需求將ui function與server function撰寫完畢。 Run App位置: 若為了管理程式碼方便，除了將前後端程式整合成app.R外，也可將前後端程式碼分開成兩個R Scripts，分別為前端ui.R以及後端server.R，如同app.R，此前後端程式碼的檔名是固定的，不能修改。 2.2 使用者介面 (User Interface) 使用者介面(User Interface)的功能是設定程式前端的功能與樣貌，包含輸入 (input)與輸出 (output)相關元件，在前述app.R的範例中，使用者介面的程式碼寫法如下: ui &lt;- fluidPage( # 使用者介面 ) 依照功能，我們可將以上範例拆解為ui &lt;-以及fluidPage()頁面設定函數兩個部分: ui &lt;-: 在單一整合程式app.R的狀況下，我們需要將fluidPage()指定為變數ui，讓app.R知道哪段程式負責前端設定。 頁面設定函數xxxxPage(): 該範例使用頁面設定函數fluidPage()，依需求可選用其他頁面設定函數，如fixedPage()與navbarPage() 因此，若想要將前後端程式分開，並將前端程式獨立於ui.R檔案中，則可省略ui&lt;-，直接叫用頁面設定函數fluidPage(): fluidPage( # 使用者介面 ) 前端可包含輸入 (input)與輸出 (output)相關元件 (elements)，並以function函數方式叫用，各輸入元件介紹詳見 4，輸出元件介紹詳見 5。 fluidPage( #input() 輸入元件們 #, #output() 輸出元件們 ) 2.3 伺服器端程式 (Server Instruction) 伺服器端程式 (Server Instruction)的功能在於使用輸入元件的值，產出使用者介面(前端)所需的輸出元件，可能是資料擷取、處理、計算等程式。 在app.R中，伺服器端的程式碼寫法如下: server &lt;- function (input,output){ # 伺服器端程式 } 同前端程式碼的設定，在單一整合程式app.R的狀況下，我們需要將function (input,output){} 指定為變數server，讓app.R知道哪段程式負責後端設定。 但若想要將前後端程式分開，並將後端程式獨立於server.R檔案中，則可省略server &lt;-，直接撰寫後端函數: function (input,output){ # 伺服器端程式 } 後端函數的輸入參數包括輸入input與輸出output，分別代表前端的輸入元件 (4)與輸出元件 (5)，將於後續章節逐一介紹，當然此參數名稱也是固定的，不建議修改。 2.4 除了前後端以外的程式碼 除了使用者介面(User Interface) ui 和伺服器端程式 (Server Instruction) server 外，有時為了程式碼易讀性或是提升效能，某些程式碼需要寫在伺服器端程式 (Server Instruction) server外。 Shiny App的執行架構如下圖，當多位使用者登入Shiny App時，可能會共用一個R Session，有些部屬架構可讓同一個App開多個Session，以提升效能，但免費的部屬服務，如Shiny Server Open Source版，通常會限制一個Shiny App只能開一個R Session，若同時多人使用你的App，可能效能就會差一些。與部屬服務相關的內容可參考 Ch. 7。 圖片來源 以Shiny App的設計來說，每個使用者打開你所開發的Shiny App時，伺服器端程式 (Server Instruction)中的程式碼都會執行，但其他部分的程式只會在每個R Session開始時執行一次，也因此像是資料載入等不用每個使用者重複執行的部分，就可以考慮放在伺服器端程式 (Server Instruction) server外，降低程式碼重複執行的次數，以提升效能。 在server 函數外執行其他程式的寫法: preloadData&lt;-readRDS(&quot;xxx.RDS&quot;) ## 每個Session只會執行一次的程式碼 ui &lt;- fluidPage( # 使用者介面 ) server &lt;- function (input,output){ ## 每個使用者打開App都會重複執行的程式碼 # 伺服器端程式 } shinyApp(ui = ui, server = server) 若想在Shiny App中使用外部程式碼檔案，可直接用source()函數: source(&quot;xxx.R&quot;) #載入外部程式碼，一樣每個Session只會執行一次 preloadData&lt;-readRDS(&quot;xxx.RDS&quot;) ## 每個Session只會執行一次的程式碼 ui &lt;- fluidPage( # 使用者介面 ) server &lt;- function (input,output){ ## 每個使用者打開App都會重複執行的程式碼 # 伺服器端程式 } shinyApp(ui = ui, server = server) 2.5 參考資料 Learn Shiny LESSON 1 - Welcome to Shiny Use R scripts and data "],
["layout.html", "Ch 3 版面設定 3.1 頁面設定函數xxxPage() 3.2 xxxLayout() 和 xxxPanel() 3.3 row 與 column 3.4 參考資料", " Ch 3 版面設定 3.1 頁面設定函數xxxPage() 為了建構使用者介面(User Interface) (前端)，基本的程式碼為: fluidPage( #input() 輸入元件們 #, #output() 輸出元件們 ) 其中fluidPage()為整合輸入輸出元件的函數為頁面設定函數，本章節將介紹建構各種頁面設定函數xxxPage()的使用方法。 最常見的頁面設定函數為範例中的fluidPage()，其他頁面設定函數包括fixedPage()、navbarPage()等，其差異條列如下: fluidPage(): 頁面會依照瀏覽器的大小自動調整頁面元件的大小與位置，最常見且建議使用 fixedPage(): 頁面會固定大小，可搭配fixedRow()排版 navbarPage(): 建構有上方選單的頁面，選單可用tabPanel()設定 bootstrapPage(): 很會HTML/CSS的使用者可使用此函數，客製化設定頁面 fillPage(): 會生成一個將整個瀏覽器視窗填滿的頁面，只有在特殊情況下才會選用此函數 以fluidPage()為例，以下呈現同一程式碼在不同視窗大小的效果： fluidPage( titlePanel(&quot;My First fluidPage App&quot;), sidebarLayout( sidebarPanel(&quot;Sidebar&quot;), mainPanel(&quot;maaaaaaaain page&quot;) ) ) 視窗大小足夠時： 視窗縮小時： 也因此使用fluidPage()時，若使用者用手機或是解析度較差的裝置使用Shiny App，版面會自動調整成適合的樣子，是Shiny App預設且最常用的頁面設定函數。 使用navbarPage()則可快速建立有上方選單的網頁，選單可用tabPanel()設定，若用子選單，可將多個tabPanel()組合成子選單，並用navbarMenu()載入 navbarPage( title=&quot;My First navbarPage App&quot;, tabPanel(&quot;Nav 1&quot;), tabPanel(&quot;Nav 2&quot;), navbarMenu( &quot;Sub-Nav&quot;, tabPanel(&quot;Sub-Nav 1&quot;), tabPanel(&quot;Sub-Nav 2&quot;) ) ) navbarPage()範例： 3.2 xxxLayout() 和 xxxPanel() 在選擇完適當的頁面設定函數後，可依需求選擇特定版型(layout)與版面(panel)，通常在版型(layout)中，會再使用版面(panel)函數做更進一步的設定，當然也可直接在頁面設定函數中直接使用版面(panel)函數。最常使用的函數為titlePanel()與sidebarLayout()，titlePanel()用來設定標題，而在sidebarLayout()函數中會用sidebarPanel()與mainPanel()做出有側邊攔與主頁的版型，範例程式碼如下: fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel(&quot;Sidebar&quot;), #側邊欄位版面(panel) mainPanel(&quot;maaaaaaaain page&quot;) #主頁版面(panel) ) ) 使用titlePanel()與sidebarLayout()所設定的版面如經典的直方圖Shiny範例程式： 由範例與名稱可知，sidebarLayout()函數可生成側邊欄位加上較大主頁面的常見版型，也因此sidebarLayout()版型函數的必要參數有： - sidebarPanel()：側邊欄位版面 - mainPanel() ：主頁版面 另外，可透過position = &quot;right&quot;參數調整側邊欄位的位置，預設是左邊 fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) position = &quot;right&quot;, #調成右邊 sidebarPanel(&quot;Sidebar&quot;), #側邊欄位版面(panel) mainPanel(&quot;maaaaaaaain page&quot;) #主頁版面(panel) ) ) 在各版面(panel)函數中，可直接放入輸入輸出元件，若有更複雜的排版需求，如分頁等，就會在mainPanel() 主頁版面或其他地方放入更多的版面做進一步的調整，如使用tabsetPanel()加入分頁： fluidPage( titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel(&quot;Sidebar&quot;), #側邊欄位版面(panel) mainPanel( #主頁版面(panel) tabsetPanel( tabPanel(&quot;Tab 1&quot;), tabPanel(&quot;Tab 2&quot;), tabPanel(&quot;Tab 3&quot;) ) ) ) ) 若因所需分頁太多，tabsetPanel()無法滿足需求時，navlistPanel()是另一個不錯的選項，預設樣式是將選單排在側邊： fluidPage( titlePanel(&quot;My First navlistPanel App&quot;), navlistPanel( tabPanel(&quot;Nav 1&quot;), tabPanel(&quot;Nav 2&quot;), tabPanel(&quot;Nav 3&quot;) ) ) 3.3 row 與 column 在fluidPage()中，也可直接使用fluidRow()和column()函數做行與列的排版，通常會先排列 (row)，再排行 (column)，每行 (column)通常分為12等分，若想設定大概頁面四分之一的寬度，則寬度就設為3 (12/4=3)，下列範例特別將各column區塊著色，以方便辨識各column的寬度。 fluidPage( titlePanel(&quot;Row and Column&quot;), fluidRow( column(width=3,&quot;3-1&quot;, style = &quot;background:yellow;&quot;),#黃色 column(width=6,&quot;6&quot;, style = &quot;background:pink;&quot;),#粉紅色 column(width=3,&quot;3-2&quot;, style = &quot;background:lime;&quot;)#綠色 ) ) 使用上述Page、Layout與Panel等函數，即可將應用程式的使用者介面做系統性的設計。完成各區塊的劃分後，下一步則是在Panel中放置輸入元件 (4)與輸出元件 (5)。 3.4 參考資料 Learn Shiny Layout the user interface Application layout guide "],
["input.html", "Ch 4 輸入Inputs 4.1 參考資料", " Ch 4 輸入Inputs 為了建構使用者介面(User Interface) (前端)，基本的程式碼為: fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel(input() 輸入元件們), #側邊欄位版面(panel) mainPanel(output() 輸出元件們) #主頁版面(panel) ) ) 若需了解頁面設定函數、版面與版型的使用方式，可參考前一章節 (3)，本章節將介紹建構各種輸入元件函數的使用方法。 常見的輸入元件函數如下： 選單/選擇系列： checkboxInput(): 單一選單 checkboxGroupInput(): 可多選的選單列表 radioButtons(): 只可單選的選單列表 selectInput(): 下拉式選單 輸入系列： textInput(): 輸入文字 numericInput(): 輸入數字 dateInput(): 數入日期 dateRangeInput(): 輸入一組日期區間（兩個日期） sliderInput(): 可滑動的數字選單，初選值可有一個（0初選值）或兩個（初選值1初選值2） fileInput(): 檔案上傳 顯示系列 helpText(): 說明文字，樣式會跟一般的文字不同 按鈕系列 submitButton(): 提交按鈕 actionButton(): 觸發按鈕 上述輸入元件的顯示結果如下圖 (圖片來源)： 各種輸入元件的共用參數，包括inputId、label與...，分述如下: inputId: 為輸入元件的名稱，為每個元件取合理且唯一的名稱，才可在Shiny App程式中取用 label: 為輸入元件在畫面上呈現的名字，顯示用，因此必須輸入使用者看得懂的說明 …: 每個輸入元件會有自己的特殊設定參數，可用?輸入元件函數名稱來查詢說明文件 以sliderInput()為例，除了inputId與label外，還需要設定最小值min、最大值max以及預設數值value等三個參數，如以下範例： fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel(&quot;This is output&quot;) #主頁版面(panel) ) ) 使用上述程式碼所產出的應用程式畫面： 若想要查看各項輸入元件的範例程式碼，可至 Shiny Widgets Gallery網站查看。 4.1 參考資料 Learn Shiny Add control widgets "],
["output.html", "Ch 5 輸出 Outputs 5.1 內建輸出元件 5.2 其他常用輸出元件 5.3 參考資料", " Ch 5 輸出 Outputs 5.1 內建輸出元件 如同輸入函數，輸出函數也有共通的特性與使用方式，輸出函數的組成通常為 xxxOutput()，xxx為輸入的型式，如plot等，常見的輸出元件函數如下： 表格類 dataTableOutput(): 表格，使用DataTables JavaScript套件製作表格 tableOutput(): 表格，使用xtable製作表格 圖片類 imageOutput(): 經由超連結存取圖片 plotOutput(): 由R所產生的圖片 HTML類 htmlOutput(): HTML uiOutput(): HTML 文字類 textOutput(): 一般文字，類似HTML的 verbatimTextOutput(): 文字，類似HTML的 ，使用固定寬度的的文字，且不會修改換行跟空格等，適合呈現程式碼等格式固定的文字 輸出函數的共用參數參數只有outputId，為輸出元件的名稱，為每個元件取合理且唯一的名稱，才可在Shiny App程式中取用。 以textOutput()和dataTableOutput()為例，在指定outputId後，將各輸出元件擺在需要的位置： fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( textOutput(outputId=&quot;textBox&quot;), dataTableOutput(outputId=&quot;dataTable&quot;) ) #主頁版面(panel) ) ) 在Output()函數中，outputId=常被省略，只留下函數名稱。執行上述程式碼，會發現畫面中沒有文字與表格，那是因為文字和表格等輸出元件需要由伺服器程式碼（後端server，參考下一章節 6 ）指定內容後，才能依內容呈現。 5.2 其他常用輸出元件 5.2.1 動態表格 撰寫中 DT套件 5.2.2 動態地圖 撰寫中 Leaflet leafletjs leaflet套件 install.packages(&quot;leaflet&quot;) library(leaflet) library(leaflet) leaflet() %&gt;% addTiles() %&gt;% setView(121.388396, 25.034548, zoom=17) 在Shiny App/Dashboard 使用 leaflet 地圖 5.3 參考資料 Learn Shiny Display reactive output "],
["server.html", "Ch 6 伺服器端程式 Server 6.1 渲染函數 Render function 6.2 反應函數 Reactive function 6.3 參考資料", " Ch 6 伺服器端程式 Server Shiny App是由使用者介面(User Interface)與伺服器端程式 (Server Instruction)組合而成，而server函數中最重要的功能為產出使用者介面所需的輸出元件(內容)，本章節將介紹伺服器端程式的撰寫方法。 伺服器端程式中有server函數，server函數的格式如下: server &lt;- function (input,output){ # 伺服器端程式 input$checkbox output$plot # etc.. } 從上述程式碼可以發現在server函數中，有兩個固定的參數，分別為input與output，input為使用者介面中所包含的輸入元件，output為輸出元件。若須取用特定輸入與輸出相關元件，可使用input或output$Id作為取用路徑，如input$checkbox，output$plot等，$錢字號前方指定取用輸入元件input還是輸出元件output，後方指定元件的Id。因此，在使用者介面函數中，幫各輸入與輸出元件取容易記憶與識別的Id是很重要的。 6.1 渲染函數 Render function 為了在server函數產出輸出元件，我們必須使用渲染函數(Render function)，渲染函數與輸入輸出函數類似，有固定的格式，通常為renderXXX()，XXX為需要呈現的資料/內容格式，如Plot、Image、Table等，組合成renderPlot()、renderImage()等函數。渲染函數的輸入參數為一獨立函數，此函數必須使用{ }大括號包起來。與撰寫函數一樣，{ }大括號中可有無限多行程式碼，以製作與產生需要呈現的資料/內容，如直方圖hist(rnorm(30)) server &lt;- function (input,output){ renderPlot( { hist(rnorm(30)) } ) } 若輸出的圖形/資料會依照輸入資料改變，則需要在渲染函數中取用輸入元件，取用方式為input$Id，如input$checkbox、input$max_num等，輸入元件的值會隨著使用者介面的調整而即時變動，承上述範例，我們可以將原數值30改為由輸入元件input$max_num決定，以達成互動式應用程式的效果。 server &lt;- function (input,output){ renderPlot( { hist(rnorm(input$max_num)) } ) } 最後將渲染函數的值指定給輸出元件，如output$hist&lt;-渲染函數({#一大堆程式碼})，即完成使用者介面所需的輸出output元件的產出程式。 server &lt;- function (input,output){ output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) } 完整範例程式碼： ui &lt;- fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( plotOutput(&quot;hist&quot;) ) #主頁版面(panel) ) ) server &lt;- function (input,output){ output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) } shinyApp(ui = ui, server = server) 上述程式程式可達效果： 若想要查看各項輸入元件取值的格式與範例程式碼，可至 Shiny Widgets Gallery網站查看。 延續上一章節 (5)，常見的輸出元件函數與其對應的渲染函數如下： 表格類 dataTableOutput(): renderDataTable() tableOutput(): renderTable() 圖片類 imageOutput(): renderImage() plotOutput(): renderPlot() HTML類 htmlOutput(): renderUI() uiOutput(): renderUI() 文字類 textOutput(): renderText() verbatimTextOutput(): renderText() 6.2 反應函數 Reactive function 在使用者介面中，當輸入元件 (如input$num)的值改變時，會通知使用該輸入元件的反應函數，該反應函數會使用該輸入元件的新值，並做相對應的運算與輸出處理，上個小節介紹的渲染函數為最常見的反應函數。 以渲染函數來說，若輸入元件 (如input$max_num)的值改變時，渲染函數renderPlot({ })大括號{ }中的程式碼會從頭到尾從新執行一次。 renderPlot( { ## re-run start hist(rnorm(input$max_num)) ## re-run end } ) 6.2.1 反應函數 reactive() 在某些狀況中，渲染函數renderPlot({ })大括號{ }中的程式碼會在server function中出現多次，若每次輸入元件改變時，同樣的程式碼必須執行多次，可能會影響程式效能，此時可用反應函數reactive()，將執行結果暫存。 以下是同一系列的程式碼在server function中出現多次的情境，其中cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal)這兩行程式碼會執行多次，若程式碼更長或是更複雜一些，就會顯著的影響效能。 renderPlot( { ## re-run start cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) hist(random) ## re-run end } ) renderText( { ## re-run start cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) random ## re-run end } ) 除了效能以外，這類程式碼執行多次會有問題，通常我們要同時輸出相同資料的文字與圖片，但在此情境中，random&lt;-rnorm(cal)會在renderPlot()中執行一次，並在renderText()中執行一次，執行兩次rnorm()的結果，就是拿來畫圖的資料與文字呈現的資料並非同一組資料。為了證明兩次執行的rnorm()結果不同，進而造成圖片與文字使用的資料不同的問題，可參考以下測試程式碼。 完整範例程式碼： ui &lt;- fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( plotOutput(&quot;hist&quot;), textOutput(&quot;random&quot;) ) #主頁版面(panel) ) ) server &lt;- function (input,output){ output$hist&lt;-renderPlot( { ## re-run start cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) cat(random) hist(random) ## re-run end } ) output$random&lt;-renderText( { ## re-run start cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) random ## re-run end } ) } shinyApp(ui = ui, server = server) 上述程式碼執行後，畫圖的資料會呈現在console視窗 (節塗黑底部分)，而文字資料則是呈現在Shiny App中 (直方圖下方)，可以發現兩邊的資料是不同的: 為了解決上述相同程式碼執行多次以及可能的資料不一致問題，可用反應函數reactive()，將需重複執行的程式碼擷取至反應函數reactive()中，並將執行結果儲存至變數saved_data中，透過反應函數reactive()的設定，當輸入元件改變時，只會重複執行反應函數reactive()中的程式碼一次，再依序將執行結果渲染至輸出元件中。要特別注意的地方是在叫用saved_data時，必須以函數的方式叫用saved_data()。 範例程式碼: saved_data&lt;-reactive({ cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) random } ) renderPlot( { hist(saved_data()) } ) renderText( { saved_data() } ) 為了檢查此時文字與圖片使用資料是否一至，可複製並執行以下完整範例程式碼： ui &lt;- fluidPage( #頁面設定函數 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( plotOutput(&quot;hist&quot;), textOutput(&quot;random&quot;) ) #主頁版面(panel) ) ) server &lt;- function (input,output){ saved_data&lt;-reactive({ cal&lt;-(input$max_num*100+30)/100 random&lt;-rnorm(cal) random } ) output$hist&lt;-renderPlot( { print(saved_data()) hist(saved_data()) } ) output$random&lt;-renderText( { saved_data() } ) } shinyApp(ui = ui, server = server) 上述程式碼執行後，畫圖的資料會呈現在console視窗 (節塗黑底部分)，而文字資料則是呈現在Shiny App中 (直方圖下方)，可以發現兩邊的資料此時是一致的: 適當的使用反應函數reactive()可減少相同程式碼的執行次數，也可避免可能的資料不一致問題。 6.2.2 不反應 isolate() isolate() 將不需即時反應/重跑程式的輸入元件放入隔離函數isolate()中，即可將此輸入元件變成非反應元件，當此輸入元件改變時，程式並不會重跑。此法避免不必要的程式重跑，提升效能與使用者體驗。 isolate(rnorm(input$max_num)) 6.2.3 按鈕觸發 observeEvent() observeEvent()通常搭配actionButton()使用，observeEvent()的第一個參數為追蹤的輸入元件，通常為按鈕，第二個參數則為按鈕點選後需要執行的程式碼，當observeEvent()中的輸入元件改變時，如點選某個action button，將會觸發後續程式碼的執行，如下列程式碼所示，第一個參數為input$action，為actionButton()，第二個參數則是將資料放入圖型輸出元件。在程式碼執行時，調整input$max_num的值，以及點選input$action按鈕，都會觸發圖片更新。 server &lt;- function (input,output){ observeEvent(input$action, { output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) }) } 完整的可執行程式碼如下: library(shiny) ui &lt;- fluidPage( titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ), actionButton(&quot;action&quot;, &quot;點我重畫圖&quot;) ), mainPanel( plotOutput(&quot;hist&quot;), ) #主頁版面(panel) ) ) server &lt;- function (input,output){ observeEvent(input$action, { output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) }) } shinyApp(ui = ui, server = server) 由操作執行結果可發現不管是滑動數值或是點選按鈕，都能觸發圖片更新。 6.2.4 延遲反應 eventReactive() 根據上述反應函數的介紹，通常輸入元件改變時，反應函數會即時反應，並改變輸出內容，但有時我們想避免不必要的即時反應，舉例來說，上述使用observeEvent()的範例可以實作在數值更新以及點選按鈕時都更新圖片的網頁，但有時我們希望能在點選按鈕時才更新網頁，數值更新時網頁則不做任何變動，此時可使用eventReactive()函數實作延遲反應的功能，如下列程式碼所示，eventReactive()函數的第一個參數為按鈕輸入元件，如input$action，第二個參數為按鈕被點選後需要執行的程式碼，通常包括其他不想要程式即時反應變動的輸入元件，如input$max_num。eventReactive()函數的輸出必須存在一變數中，以randomVals為例，在渲染函數叫用此變數時，需要用function的方式叫用，如hist(randomVals()) server &lt;- function (input,output){ randomVals &lt;- eventReactive(input$action, { rnorm(input$max_num) }) output$hist&lt;-renderPlot( { hist(randomVals()) } ) } 完整可執行程式碼如下: ui &lt;- fluidPage( titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ), actionButton(&quot;action&quot;, &quot;點我重畫圖&quot;) ), mainPanel( plotOutput(&quot;hist&quot;), ) #主頁版面(panel) ) ) server &lt;- function (input,output){ randomVals &lt;- eventReactive(input$action, { rnorm(input$max_num) }) output$hist&lt;-renderPlot( { hist(randomVals()) } ) } shinyApp(ui = ui, server = server) 由操作執行結果可發現只有點選按鈕才能觸發圖片更新。 6.2.5 reactiveValues() 撰寫中 reactiveValues() 藉由輸入函數，修改自定義的資料內容，接著觸發反應函數的功能，並更新相對應的輸出 6.2.6 reactiveTimer() 撰寫中 timer reactiveTimer() 6.3 參考資料 Learn Shiny Display reactive output "],
["deploy.html", "Ch 7 將Shiny App上線", " Ch 7 將Shiny App上線 完成Shiny App的撰寫後，即可將Shiny App放上網路，供大家使用，使用Shiny app可以不用安裝R，並且一般的瀏覽器即可開啟。將Shiny放上網路(上線)有下列幾種方式: shinyapps.io 最簡單無腦的方法，推薦新手練功使用 將Shiny App架在RStudio提供的伺服器上 在一定使用量且公開應用程式的情況下免費 若超過免費使用額度或是需要特殊功能，有多種付費套組可供選擇 需要安裝rsconnect套件 官方參考文件 shinyapps.io user guide - Getting Started 為確保安裝的rsconnect套件為最新版，建議可透過GitHub裝開發版，功能較新且齊全: install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rstudio/rsconnect&quot;) Shiny Server 將Shiny App架在自己的伺服器上 目前只可安裝在linux伺服器，若無linux伺服器，可考慮使用雲端服務，如AWS、Google Cloud Service等，上述服務都有免費試用額度，若你有教師或學生身分，可申請AWS Educate，每年都會提供一定的免費使用額度，且不用信用卡就能註冊帳號，方便還沒有信用卡的學生申請，也因此我在蠻多課程中使用AWS Educate的伺服器或是資料庫等服務。 為免費軟體 (AGPL v3) 沒有授權跟SSL功能，偏私人且需要管理權限的的服務不建議使用此免費版本，除非有其他方式可控管 每個App只會有一個R session，如果會有很多使用者同時使用你的Shiny App，不建議使用 Shiny Server Pro 可將Shiny App架在自己的伺服器上 目前只可安裝在linux伺服器，若無linux伺服器，可考慮使用雲端服務，如AWS、Google Cloud Service等 為收費軟體，與Shiny Server免費版的差異是： 有授權機制且有SSL 每個Shiny App可有多個R session，在較多使用者的情況下，效能會顯著提升 有管理者監控儀表板服務 提供教育授權，可在官方網頁填單申請 RStudio Connect 將Shiny App架在自己的伺服器上，但比Shiny Server和Shiny Server Pro容易上手，因此也貴很多 為付費服務，適合提供資料分析/科學服務或研究的機構使用，有許多整合型的功能，包括使用者權限管理等，均可使用管理者介面設定 與Shiny Server不同的是，除了Shiny App外，RStudio Connect還可放R Markdown, Plumber API’s, 以及 Jupyter Notebooks等 有多種收費方案 提供教育授權，可在官方網頁填單申請 上述服務的比較，也可參考RStudio的官方文章 What is the difference between RStudio Connect, Shiny Server Pro, and Shinyapps.io? "],
["design.html", "Ch 8 客製化使用者介面 8.1 樣式模板 8.2 R -&gt; HTML 8.3 CSS 8.4 參考資料", " Ch 8 客製化使用者介面 在之前的章節，我們透過使用者介面設計 (含輸入 Ch. 4 與輸出 Ch. 5)、伺服器端程式設計 Ch. 6以及部屬上線 Ch. 7 等三個步驟完成Shiny App的製作與上線，但Shiny App也提供許多客製化設定的功能，包括使用者介面 (本章節)，儀表板設計 Ch. 9，以及叫用另外的程式碼檔案 Ch. 2.4、JavaScript函式庫 Ch. 4 等。此外，我們也可在上線前測試Shiny App的介面與效能 Ch. 12 ，以免程式效能不佳影響使用者體驗。 8.1 樣式模板 若想改變Shiny App的外觀，安裝shinythemes(Chang 2018)套件，可輕鬆的將內建的Bootstrap模板套用在你所開發的Shiny App中，shinythemes套件的模板多來自Boostwatch網站，可直接去該網站查看所有模板。 要使用shinythemes套件，依照R套件的使用原則，第一次使用必須先安裝install.packages()再載入library()，未來只需再次載入即可 install.packages(&quot;shinythemes&quot;) library(shinythemes) 在完成shinythemes套件的安裝與載入後，即可在Shiny App中套用樣式模板，套用方式是在使用者介面（前端）的頁面設定函數，如fluidPage()中，增加一參數theme = shinytheme(&quot;樣式名稱&quot;)，樣式的名稱可在Boostwatch網站查看。 以下以superhero樣式為例，在使用者介面（前端）ui的fluidPage()函數中，增加一行theme = shinytheme(&quot;superhero&quot;),： ui &lt;- fluidPage( #頁面設定函數 theme = shinytheme(&quot;superhero&quot;), titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) ) 可執行的完整範例程式碼： ui &lt;- fluidPage( #頁面設定函數 theme = shinytheme(&quot;superhero&quot;), titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( plotOutput(&quot;hist&quot;) ) #主頁版面(panel) ) ) server &lt;- function (input,output){ output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) } shinyApp(ui = ui, server = server) 在沒增加theme = shinytheme(&quot;superhero&quot;),之前，原輸出樣式為： 加了theme = shinytheme(&quot;superhero&quot;),參數後的樣式： 執行像上述修改為深色基底的程式碼時，會發現圖片還是白底為主，若覺得這樣不妥，可加上shinyOptions(plot.autocolors=T)設定，不過這個功能在下個版本才會正式上線。 若無法馬上決定樣式，想更進一步看到各種樣式模板使用後的應用程式外觀，可在UI的頁面設定函數中加上一參數themeSelector(),，啟動樣式選擇器，當然在使用前也需載入shinythemes套件。 在下方可執行的完整範例程式碼中，頁面設定函數fluidPage()的第一個參數即為樣式選擇器： ui &lt;- fluidPage( #頁面設定函數 themeSelector(), # 樣式選擇器 titlePanel(&quot;My First Shiny App&quot;), #標題版面(panel) sidebarLayout( #版型(layout) sidebarPanel( #側邊欄位版面(panel) sliderInput( #輸入元件函數 inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25 ) ), mainPanel( plotOutput(&quot;hist&quot;) ) #主頁版面(panel) ) ) server &lt;- function (input,output){ output$hist&lt;-renderPlot( { hist(rnorm(input$max_num)) } ) } shinyApp(ui = ui, server = server) 執行上述程式碼即可開啟樣式選擇器: 網路上還有許多套件可讓使用者快速套用已設計好的樣式，如： - shinymaterial : 讓使用者可應用Google’s Material design概念與元件，可至官網查看套用效果 - RinteRface推出的各種套件，如 shinyMobile GitHub連結 : 提供製作適合手機使用的Shiny App模板： 圖片來源 8.2 R -&gt; HTML 撰寫中 此部分建議比較熟HTML或是想要學HTML的使用者閱讀。 8.2.1 HTML 101 8.2.2 在R中撰寫HTML tags A list of functions tags$h1() tags$h2() tags$a(href=&quot;~&quot;,&quot;book&quot;) &lt;a href=&quot;~&quot;&gt;&quot;book&quot;&lt;/a&gt; www folder 8.3 CSS 撰寫中 code cademy css leasson CSS教材 在Shiny App使用CSS 1. 使用css file (放在專案資料夾中的www資料夾) 2. 在header中直接撰寫css 3. 在每個tag中分別撰寫css Tag -&gt; Class -&gt; id fluidPage( theme = &quot;xxx.css&quot; ) fluidPage( tags$head( rel=&quot;stylesheet&quot;, xx, xx ) ) fluidPage( includeCSS(&quot;xxx.css&quot;) #只要放在專案資料夾就好，不用放在www資料夾中 ) 8.3.1 Bootstrap and Sass CSS framework sass bootstraplib 8.4 參考資料 How to Start Shiny tutorial Shiny Themes Styling Shiny apps with Sass and Bootstrap 4 - Joe Cheng shinymaterial References "],
["dashboard.html", "Ch 9 儀表板 9.1 開發儀表板步驟 9.2 儀表板樣式設計 9.3 參考資料", " Ch 9 儀表板 儀表板 (Dashboard)通常是指將資料分析結果，如圖、表與重要的數字等，以單一頁面 (通常是網頁)的方式呈現，目前有許多軟體與服務提供使用者快速的製作自己的儀表板: Power BI: 跟微軟的Office軟體整合的很不錯，免費服務包含單機使用或是在公開網路儀表板，若要開發需要帳號密碼授權的儀表板，則需要付費 tableau: 應該是最紅的儀表板服務，一樣有免費與付費服務供使用 SAS Visual Analytics QlikView 除了上述服務外，當然也可以使用Shiny App開發儀表板，Shiny的主要特色就是將資料分析結果轉換成互動式的網頁應用程式，簡單來說就是動態網站，因此也很適合做為開發儀表板的工具。跟上述服務不同的是，要Shiny App需要學習R語言，也須學習Shiny App的開發方式，相較於拖拉式的服務，入門稍微困難一些，但也增加了許多彈性。 9.1 開發儀表板步驟 在開始用Shiny開發儀表板前，建議先完成以下3個步驟: 釐清設計儀表板的目的: 儀表板的設計通常與需達成的目的有關，如幫助商業決策、監控工廠訂單、以及監控傳染病等，因此在設計儀表板前，建議先將目標訂定清楚，再開始動工。 設定目標對象: 是否有特定的目標，若特定目標過去已有看類似報表的習慣，呈現分析結果的方式是什麼? 如果目標為一般人，可能沒有足夠的背景知識，圖表複雜度與說明文字的配置則需要多做考慮。 了解使用方式: 是否都用電腦看? 還是用平板或是手機? 如果用電腦看，通常螢幕大概多大? 是否會用投影的方式在會議中呈現? 以上幾個問題會影響版面設計，以及字型大小等，建議先釐清。 完成上述步驟後，即可開始開發儀表板，而用Shiny開發儀表板大多遵循下列4個步驟: 將須呈現的資料載入儀表板 如何快速的將資料載入是設計儀表板必須解決的問題，若資料載入時間太久，通常分析也會很慢，會降低使用者體驗，因此，若需要分析的資料很大，可考慮用批次的方式，撰寫其他程式先作預處理，降低資料量，以加快資料存取速度。資料匯入的方式與一般R程式相同，可參考資料科學與R語言 - 資料讀取與匯出章節。一般分為以下幾種情境: 讀取資料庫: 可用DBI 套件 讀取檔案: 可用readr 套件，可參考資料科學與R語言 - 資料讀取與匯出章節 透過API載入: 可用jsonlite, readr, 或是xml2套件，可參考資料科學與R語言 - 透過API讀取資料章節 資料處理分析 資料呈現 資料呈現可能有以下方式: 數字與文字: renderText() 表格: renderTable(), DT套件支援互動式表格 圖片: renderPlot() 地圖: ggmap套件，或是leaflet套件支援互動式地圖 增加互動性 使用先前介紹的輸入元件4，讓使用者調整輸入值，作為改變輸出圖表的依據。以開發新冠肺炎案例數呈現的儀表板為例，可能可以讓使用者用下拉選單選擇呈現國家、用check box選擇區域、或是用slider選擇特定時間區間等。 9.2 儀表板樣式設計 使用shinydashboard(Chang and Borges Ribeiro 2018)套件，使用者可快速製作像儀表板的Shiny App，因原理與基本架構都是使用Shiny，程式的基本架構與Shiny App相同，包含使用者介面(User Interface)與伺服器端程式 (Server Instruction)兩個部分。使用shinydashboard套件，也須在第一次使用前安裝，之後則執行載入即可。 install.packages(&quot;shinydashboard&quot;) library(shinydashboard) 9.2.1 dashboardPage() 比較特別的是，在使用者介面(User Interface)中，通常會使用dashboardPage()函數建構，而非常見的fluidPage()函數。 ui &lt;- dashboardPage( #使用者介面程式 ) Shiny Dashboard的標準架構包括儀表板標頭 (header) dashboardHeader()、側邊選單 (sidebar) dashboardSidebar() 以及主頁面 (body) dashboardBody() 等三個部分，可依序將此三部分分別輸入在dashboardPage()函數中。 ui &lt;- dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody() ) 比較複雜的應用程式，也可使用下列方式撰寫儀表板架構: header &lt;- dashboardHeader() sidebar &lt;- dashboardSidebar() body &lt;- dashboardBody() ui &lt;- dashboardPage(header, sidebar, body) 9.2.2 標頭 dashboardHeader()維儀表板儀表板標頭，可在標頭中用title參數設定儀表板標題，如下列程式碼所示: ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;), dashboardSidebar(), dashboardBody() ) 除了標題外，標頭部分還可使用dropdownMenu()加入其他選單，常見的元件有: 訊息選單 messageItem() 通知選單 notificationItem() 工作選單 taskItem() 可分別在畫面右上角加入選單資訊，在dropdownMenu()中，可用type設定右上角選單呈現的icon，並對應上述三個常見的元件，三個元件各有特定參述可供設定，可依需求選用，比較特別的是在工作選單中可設定每個工作的進度。 ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;, dropdownMenu(type = &quot;messages&quot;, messageItem( from = &quot;訊息來源&quot;, message = &quot;訊息內容&quot;) ), dropdownMenu(type = &quot;notifications&quot;, notificationItem( text = &quot;通知通知&quot;, icon(&quot;users&quot;)) ), dropdownMenu(type = &quot;tasks&quot;, taskItem(value = 90, color = &quot;green&quot;,&quot;工作進度&quot;) ) ), dashboardSidebar(), dashboardBody() ) 右上角加入選單資訊呈現方式如下圖: 若想在後端修改選單元件，則需使用dropdownMenuOutput()設定輸出元件，並在伺服器端程式用renderMenu()作動態設定。 前端範例: ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;, dropdownMenuOutput(&quot;msg_menu&quot;), dropdownMenuOutput(&quot;tsk_menu&quot;) ), dashboardSidebar(), dashboardBody() ) 後端範例: server&lt;-function(input,output){ output$msg_menu &lt;- renderMenu({ dropdownMenu(type = &quot;messages&quot;, messageItem( from = &quot;訊息來源&quot;, message = &quot;訊息內容&quot;) ) }) output$tsk_menu &lt;- renderMenu({ dropdownMenu(type = &quot;tasks&quot;, taskItem(value = 90, color = &quot;green&quot;,&quot;工作進度&quot;) ) }) } 會得到類似的輸出結果。 若不需要標頭，也可將標頭關掉: ui &lt;- dashboardPage( dashboardHeader(disable = TRUE), dashboardSidebar(), dashboardBody() ) 9.2.3 側邊欄位 而側邊欄位dashboardSidebar()可由選單sidebarMenu()組成，每個選單sidebarMenu()中可有多個選項meunItem()，在選項中除可在第一個參數設定選項名稱外，也必須用tabName參數設定選項ID，以及icon參數加上圖示，幫助使用者理解內容，選項ID的功能是用來對應主頁面dashboardBody()的內容。可用的icon可見 Font-Awesome 以及 Glyphicons兩個網站。 ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;), dashboardSidebar( # 側邊欄位 sidebarMenu( # 選單 menuItem(&quot;選項名稱1&quot;, tabName = &quot;id_1&quot;, icon = icon(&quot;dashboard&quot;)),# 選項1 menuItem(&quot;選項名稱2&quot;, tabName = &quot;id_2&quot;, icon = icon(&quot;th&quot;))# 選項2 ) ), dashboardBody() ) 若不需要側邊欄位，也可將側邊欄位關掉: ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;), dashboardSidebar(disable = TRUE), dashboardBody() ) 9.2.4 主頁面 主頁面dashboardBody()則是使用tabItems()來排版，在tabItems()中可用多個tabItem()來對應側邊欄位的每個選項，對應方式為設定相同的tabName，而在tabItems()中，再使用列fluidRow和欄位column或是資訊區塊box的方式將圖表排版。排版可參考Ch. 3.3 ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;), dashboardSidebar( # 側邊欄位 sidebarMenu( # 選單 menuItem(&quot;選項名稱1&quot;, tabName = &quot;id_1&quot;, icon = icon(&quot;dashboard&quot;)),# 選項1 menuItem(&quot;選項名稱2&quot;, tabName = &quot;id_2&quot;, icon = icon(&quot;th&quot;))# 選項2 ) ), dashboardBody( tabItems( tabItem(tabName = &quot;id_1&quot;, # 對應選項1 fluidRow( box(sliderInput( inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25)), box(plotOutput(&quot;hist&quot;)) ), fluidRow(box(&quot;Row 2&quot;)) ), tabItem(tabName = &quot;id_2&quot;, # 對應選項2 h2(&quot;第二頁&quot;) ) ) ) ) 呈現的效果如下所示: 若有較重要的資訊，需要放在顯眼的地方，且有較特別的樣式，可用infoBox()和valueBox()呈現，這兩個Box的功能差不多，只是樣式稍有不同。 ui &lt;- dashboardPage( dashboardHeader(title=&quot;My First Dashboard&quot;), dashboardSidebar( # 側邊欄位 sidebarMenu( # 選單 menuItem(&quot;選項名稱1&quot;, tabName = &quot;id_1&quot;, icon = icon(&quot;dashboard&quot;)),# 選項1 menuItem(&quot;選項名稱2&quot;, tabName = &quot;id_2&quot;, icon = icon(&quot;th&quot;))# 選項2 ) ), dashboardBody( tabItems( tabItem(tabName = &quot;id_1&quot;, # 對應選項1 fluidRow( box(sliderInput( inputId = &quot;max_num&quot;, label =&quot;Choose a number&quot;, min = 0, max = 100, value =25)), box(plotOutput(&quot;hist&quot;)) ), fluidRow(box(&quot;Row 2&quot;)) ), tabItem(tabName = &quot;id_2&quot;, # 對應選項2 infoBox(&quot;重要資訊! Info&quot;, 50, icon = icon(&quot;credit-card&quot;)), valueBox(&quot;重要資訊! Value&quot;, 60, icon = icon(&quot;thumbs-up&quot;)) ) ) ) ) 呈現的效果如下所示: 9.3 參考資料 shinydashboard Dynamic Dashboards with Shiny References "],
["covid19.html", "Ch 10 新冠肺炎儀表板範例 10.1 儀表板主要架構 10.2 流行地圖 UI 10.3 各國圖表 UI 10.4 伺服器端程式 10.5 資料整理獨立程式碼", " Ch 10 新冠肺炎儀表板範例 儀表板Demo網址: http://shiny.yjtseng.info/content/18/ 本章節以2019年末至2020年的新冠肺炎 (COVID-19)流行趨勢儀表板作為Shiny App的開發與應用範例。本範例包括三個主要分頁，流行地圖、案例數、死亡數較多的的國家圖表以及所選國家圖表，畫面如下所示： 地圖： 排名前N名的國家圖表： 自選國家圖表： 以下章節會拆解此Shiny App的原始碼，分段講解如何開發此新冠肺炎 (COVID-19)流行趨勢儀表板，建議先看完前幾個章節後，再閱讀此範例解說，會比較清楚。 10.1 儀表板主要架構 此儀表板直接使用shinydashboard(Chang and Borges Ribeiro 2018)套件開發，在使用者介面端，使用預設頁面設定函數dashboardPage()建構，函數中包括儀表板標頭 (header) dashboardHeader()、側邊選單 (sidebar) dashboardSidebar() 以及主頁面 (body) dashboardBody() 等三個部分。 儀表板標頭 (header) dashboardHeader()並未作太特殊的設定 側邊選單 (sidebar) dashboardSidebar()中包含四個選單，分別是流行地圖 map_tab、案例數、死亡數較多的的國家圖表 chart_top_tab、所選國家圖表 chart_sel_tab以及參考資料 ref_tab 主頁面 (body) dashboardBody() 則是對應側邊欄位的四個選單，分別設定四個tabItem，並用fluidRow()排版，因此部分內容較多，~code code code~部分程式碼在後方章節說明 主要架構如下方程式碼: ui &lt;- dashboardPage( ######################################################################################## # UI Header, simple header ######################################################################################## dashboardHeader(title=&quot;COVID-19 Dashboard&quot;), ######################################################################################## # UI Sidebar ######################################################################################## dashboardSidebar( sidebarMenu( menuItem(&quot;Map&quot;, tabName = &quot;map_tab&quot;, icon = icon(&quot;map-marked&quot;)), hr(), menuItem(&quot;Chart, Top N&quot;, tabName = &quot;chart_top_tab&quot;, icon = icon(&quot;chart-bar&quot;)), menuItem(&quot;Chart, Selected Countries&quot;, tabName = &quot;chart_sel_tab&quot;, icon = icon(&quot;chart-bar&quot;)), menuItem(&quot;Reference&quot;, tabName = &quot;ref_tab&quot;, icon = icon(&quot;info-circle&quot;)) ) ), ######################################################################################## # UI Body, style setting and tabItems with 4 tabItem (match menu) ######################################################################################## dashboardBody( fluidRow( tabItems( tabItem(&quot;map_tab&quot;,fluidRow(~code code code~)), tabItem(&quot;chart_top_tab&quot;,fluidRow(~code code code~)), tabItem(&quot;chart_sel_tab&quot;,fluidRow(~code code code~)), tabItem(&quot;ref_tab&quot;,fluidRow(~code code code~)) ) ) ) ) 10.2 流行地圖 UI 由上圖可知，此流行地圖是由一個日期的滑動軸sliderInput、單選選單radioButtons、兩個數值方塊uiOutput以及最重要的地圖leafletOutput所組成。 以下方簡化過的程式碼做說明，首先用兩個fluidRow將上方選單與案例數值區塊與下方地圖區塊分開，上方區塊先使用一個box以及兩個uiOutput排版，box的寬度為8，兩個uiOutput的寬度各為2，留在伺服器端程式設定，相加起來 (8+2+2=12)為12。box中放置兩個column排版，分別放入日期的滑動軸sliderInput以及單選選單radioButtons，寬度各為5和7，一樣加起來要是12。下方區塊則相較單純，只用了wellPanel排版，並放入leafletOutput顯示地圖。 ui &lt;- dashboardPage( dashboardBody( fluidRow( tabItems( tabItem(&quot;map_tab&quot;, # info above map fluidRow( # box with slider and radio buttom for period selection box(column(sliderInput(~code code code~), width=5,offset=0.5), column(radioButtons(~code code code~), width=7), width=8), # 2 value boxes with case and death number uiOutput(&quot;total_case&quot;), uiOutput(&quot;total_death&quot;) ), # map fluidRow(wellPanel(leafletOutput(&quot;case_map&quot;))) ), # tabItem 1 (map) end tabItem(&quot;chart_top_tab&quot;,~code code code~), # tabItem 2 (top N chart) tabItem(&quot;chart_sel_tab&quot;,~code code code~), # tabItem 3 (selected countries chart) tabItem(&quot;ref_tab&quot;,~code code code~) # tabItem 4 (reference) ) ) ) ) 完整的程式碼如下: ui &lt;- dashboardPage( dashboardBody( fluidRow( tabItems( tabItem(&quot;map_tab&quot;, # info above map fluidRow( # box with slider and radio buttom for period selection box(column( sliderInput(&quot;period&quot;, &quot;Data period:&quot;, min = min(covid_country_long$Date), max = max(covid_country_long$Date), value=c(min(covid_country_long$Date), max(covid_country_long$Date)), timeFormat=&quot;%Y/%m/%d&quot;), width=5,offset=0.5), column( radioButtons(&quot;period_quick&quot;,label = &quot;Quick select:&quot;, choices = list(&quot;One day&quot; = 1, &quot;One week&quot; = 2, &quot;Twe weeks&quot; = 3, &quot;One month&quot; = 4, &quot;Whole period&quot; = 5), selected = 5, inline = T), width=7,style=&quot;padding:20px;&quot;), width=8), # 2 value boxes with case and death number uiOutput(&quot;total_case&quot;), uiOutput(&quot;total_death&quot;) ), # map fluidRow(wellPanel(leafletOutput(&quot;case_map&quot;))) ), # tabItem 1 (map) end tabItem(&quot;chart_top_tab&quot;,~code code code~), # tabItem 2 (top N chart) end tabItem(&quot;chart_sel_tab&quot;,~code code code~), # tabItem 3 (selected countries chart) end tabItem(&quot;ref_tab&quot;,~code code code~) # tabItem 4 (reference) end ) ) ) ) 互動式地圖執行畫面： 10.3 各國圖表 UI 因各國圖表的介面設計差不多，以下以自選國家圖表頁面chart_sel_tab為例，說明UI安排方式，其它部分程式碼則簡化以方便說明。 自選國家圖表： 由上圖可知，本頁面由上方國家複選框selectizeInput、調整是否將數字做指數轉換的單選選單radioButtons以及下方共四個折線圖組成。 以下方簡化過的程式碼做說明，首先用三個fluidRow將上方選單曲塊與下方折線圖(兩兩一組)區塊分開，上方區塊先使用兩個box排版，box的寬度均為4，相加起來並非12，剩下的區塊(6)留著未來擴充用。第一個box中放入國家多選的輸入框selectizeInput，第二個box放入調整指數轉換的單選選單radioButtons。下方兩個區塊則分別用兩個column排版，每個column放入一個標題htmlOutput以及一個圖plotlyOutput。 ui &lt;- dashboardPage( dashboardBody( fluidRow( tabItems( tabItem(&quot;map_tab&quot;,~code code code~), # tabItem 1 (map) tabItem(&quot;chart_top_tab&quot;,~code code code~), # tabItem 2 (top N chart) tabItem(&quot;chart_sel_tab&quot;, fluidRow( box(selectizeInput(&quot;country_select&quot;, &quot;Selected countries:&quot;, unique(covid_country_long$`Country/Region`), selected = c(&quot;Taiwan&quot;,&quot;China&quot;,&quot;Iran&quot;,&quot;Italy&quot;, &quot;United States of America&quot;), multiple = T, options = NULL), width=4), box(radioButtons(&quot;log_sel&quot;,label = &quot;Scale: &quot;, choices = list(&quot;Linear Scale&quot; = 1, &quot;Logarithmic Scale&quot; = 2), selected = 1, inline = T), width=4) ), fluidRow(column(htmlOutput(&quot;country_text&quot;), plotlyOutput(&quot;case_plot_country&quot;), width=6), column(htmlOutput(&quot;country_new_text&quot;), plotlyOutput(&quot;newcase_plot_country&quot;), width=6)), fluidRow(column(htmlOutput(&quot;country_death_text&quot;), plotlyOutput(&quot;death_plot_country&quot;), width=6), column(htmlOutput(&quot;country_epi_text&quot;), plotlyOutput(&quot;epi_plot_country&quot;), width=6)), # info tables htmlOutput(&quot;country_table_text&quot;), fluidRow(wellPanel(DTOutput(&quot;table_country&quot;))) ), # tabItem 3 (selected countries chart) end tabItem(&quot;ref_tab&quot;,~code code code~) # tabItem 4 (reference) end ) ) ) ) 互動式圖表執行畫面： 10.4 伺服器端程式 本儀表板伺服器端程式共可分四個部分，分別是UI文字設定、UI圖表設定、更新圖表的反應函數以及偵測輸入元件改變以更新資料的反應函數，此部分程式碼均須放在server function內，為解說方便，省略server&lt;-function(input,output, session){ } 10.4.1 UI文字設定 在UI文字設定中，將程式碼粗略分成: Footer註腳中的最新更新日期設定 圖表標題隨使用者操作動態更新 個案數與死亡人數隨使用者選擇區間動態計算更新 若儀表板文字不會隨著使用者操作而變動，通常會在UI前端程式就設定好文字內容，如此範例儀表板的Reference參考資料部分，但若想要讓文字可隨著使用者操作或是資料自動更新，就須在伺服器端程式設定。 首先在Footer註腳部分，因更新日期要隨著資料更新而改變文字，意即使用資料的最新（最大）日期，因此在伺服器端設定，此處使用彈性較大的renderUI()搭配可使用HTML標籤的tagList()做設計與排版。 ### Footer output$update&lt;-renderUI(tagList( paste0(&quot;Update: &quot;,max(covid_country_long$Date)), br(), &quot;Data source:&quot;, a(href=&quot;https://github.com/CSSEGISandData/COVID-19&quot;,&quot;JHU CSSE&quot;,target=&quot;_blank&quot;), br(), &quot;Made by:&quot;, a(href=&quot;https://yjtseng.info&quot;,&quot;Yi-Ju Tseng&quot;,target=&quot;_blank&quot;), ) ) 圖表的標題也希望可隨著使用者選擇國家數量做變動，如果選案例數前5名的國家，或是自選了6個國家等，都會直接在標題更新，此處一樣使用renderUI()作標題文字設定。 ### Plot Title output$topN_text&lt;- renderUI(h3(paste(&quot;Total cases, top&quot;,input$topN,&quot;countries&quot;))) output$topN_new_text&lt;- renderUI(h3(paste(&quot;Daily new cases, top&quot;,input$topN,&quot;countries&quot;))) output$country_text&lt;- renderUI(h3(paste(&quot;Total cases in selected &quot;,length(input$country_select)),&quot; countries&quot;)) output$country_new_text&lt;- renderUI(h3(paste(&quot;Daily new cases in selected &quot;,length(input$country_select)),&quot; countries&quot;)) output$country_text_t&lt;- renderUI(h3(paste(&quot;Total cases in&quot;,input$country,&quot;, table&quot;))) output$topN_death_text&lt;- renderUI(h3(paste(&quot;Total death, top&quot;,input$topN,&quot;countries&quot;))) output$country_death_text&lt;- renderUI(h3(paste(&quot;Total death in selected &quot;,length(input$country_select)),&quot; countries&quot;)) output$country_death_text_t&lt;- renderUI(h3(paste(&quot;Total death in&quot;,input$country,&quot;, table&quot;))) output$topN_epi_text&lt;- renderUI(h3(paste(&quot;Number of death since 10th death&quot;))) output$country_epi_text&lt;- renderUI(h3(paste(&quot;Number of death since 10th death&quot;))) output$country_epi_text_t&lt;- renderUI(h3(paste(&quot;Number of death since 10th death&quot;))) 最後則是地圖上個案數與死亡人數的數值文字，希望隨著使用者所選區間更新，使用renderUI()加上valueBox()設定，未使用renderValueBox()是因為renderValueBox()沒有設定寬度的功能，均使用預設寬度4，這個功能開發者可能未來會修正，因此使用較麻煩的renderUI()加上valueBox()方式，將寬度設為2。 ### valueBox output$total_case &lt;- renderUI ({ valueBox( value=format(sum(world_case_dym()@data$NewCaseTotal,na.rm=T), big.mark=&quot;,&quot;), subtitle=paste0(&quot;Cases, &quot;,input$period[1],&quot; to &quot;,input$period[2]), icon = icon(&quot;diagnoses&quot;, lib = &quot;font-awesome&quot;), color = &quot;yellow&quot;,width=2 ) }) output$total_death &lt;- renderUI ({ valueBox( value=format(sum(world_case_dym()@data$NewDeathTotal,na.rm=T), big.mark=&quot;,&quot;), subtitle=paste0(&quot;Death, &quot;,input$period[1],&quot; to &quot;,input$period[2]), icon = icon(&quot;skull&quot;, lib = &quot;font-awesome&quot;), color = &quot;red&quot;,width=2 ) }) 10.4.2 UI圖表設定 在UI圖表設定中，將程式碼粗略分成: 日期選擇的slider與日期區間快速選單連動 地圖設定更新 圖片更新 表格更新 為了分析疫情方便，儀表板中使用RadioButton設計了日期區間快速選單，讓想看單月或是單週狀況的使用者可以不用慢慢拉日期slider，此步驟可以用RadioButton連動地圖，或是RadioButton連動日期Slider，再由日期Slider連動地圖更新，為了使畫面資訊統一，避免日期快速選單資訊與日期選擇slider資訊不一致 (例如slider是全時，但快速選單是一週)，本儀表板選擇使用RadioButton連動日期Slider，再由日期Slider連動地圖更新。此處更新slider使用observeEvent()追蹤RadioButton日期區間快速選單的變化，若偵測到改變，則執行一連串的ifelse，並使用內建的updateSliderInput()更新日期Slider。 ## slider auto update observeEvent(input$period_quick, { if(input$period_quick==&quot;1&quot;){ updateSliderInput(session, &quot;period&quot;, value = c(max(covid_country_long$Date), max(covid_country_long$Date))) }else if(input$period_quick==&quot;2&quot;){ updateSliderInput(session, &quot;period&quot;, value = c(max(covid_country_long$Date)-7, max(covid_country_long$Date))) }else if(input$period_quick==&quot;3&quot;){ updateSliderInput(session, &quot;period&quot;, value = c(max(covid_country_long$Date)-14, max(covid_country_long$Date))) }else if(input$period_quick==&quot;4&quot;){ updateSliderInput(session, &quot;period&quot;, value = c(max(covid_country_long$Date)-30, max(covid_country_long$Date))) }else if(input$period_quick==&quot;5&quot;){ updateSliderInput(session, &quot;period&quot;, value = c(min(covid_country_long$Date), max(covid_country_long$Date))) } }) 疫情地圖套用開源的Leaflet地圖，更新與設計直接使用renderLeaflet()功能，使用addPolygons()將地圖的國家邊界畫出來，並設定使用案例數著色fillColor = ~pal(NewCaseTotal)，當滑鼠游標滑過時，使用highlight = highlightOptions()將該國邊界顏色改變，以凸顯游標所在國家，同時使用label = ~lab設定彈出資訊視窗的內容，~lab內容的設計在資料產出時即完成，會在後面章節介紹。最後使用addLegend()加上圖標，讓使用者判斷每個顏色對應的案例數，以及用setView設定地圖載入時的預設中心位置和地圖大小。 ## map output components setting output$case_map&lt;-renderLeaflet({ #world_case period..... leaflet(world_case_dym()) %&gt;% addProviderTiles(&quot;MapBox&quot;, options = providerTileOptions( id = &quot;mapbox.light&quot;, accessToken = Sys.getenv(&#39;MAPBOX_ACCESS_TOKEN&#39;)))%&gt;% addPolygons( fillColor = ~pal(NewCaseTotal), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;1&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 1, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE), label = ~lab, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;) ) %&gt;% addLegend(pal = pal, values = ~NewCaseTotal, opacity = 0.7, title = NULL, position = &quot;bottomright&quot;) %&gt;% setView(0, 25, zoom=2) }) 案例圖部分使用Plotly函式庫提供的互動式圖形功能，分為排名前幾名的圖表以及自選國家圖表，各四個圖形。設定直接使用renderPlotly()功能搭配ggplotly()將ggplot圖表帶入，ggplot圖表部分在後端使用反應函數生成，提高程式碼易讀性。 ## plot output components setting output$case_plot_top10&lt;- renderPlotly( ggplotly(plot_topN_data()) ) output$newcase_plot_top10&lt;- renderPlotly( ggplotly(plot_topN_new_data()) ) output$death_plot_top10&lt;- renderPlotly( ggplotly(plot_topN_death_data()) ) output$epi_plot_top10&lt;- renderPlotly( ggplotly(plot_topN_epi_data()) ) output$case_plot_country&lt;- renderPlotly( ggplotly(plot_country_case_data()) ) output$newcase_plot_country&lt;- renderPlotly( ggplotly(plot_country_newcase_data()) ) output$death_plot_country&lt;- renderPlotly( ggplotly(plot_country_death_data()) ) output$epi_plot_country&lt;- renderPlotly( ggplotly(plot_country_epi_data()) ) 案例數表格部分使用DT函式庫實現動態排序與搜尋功能，直接使用renderDT()功能將表格輸入即可。表格整理相關dplyr函數可參考dplyr教學。 ## table output components setting output$table_country&lt;-renderDT( covid_country %&gt;% ungroup() %&gt;% filter(`Country/Region` %in% input$country_select) %&gt;% select(`Country/Region`,date,Total_case_num,New_case_num, Total_death_num,New_death_num) %&gt;% rename(Date=date,`Total case number`=Total_case_num, `New case number`=New_case_num, `Total death number`=Total_death_num, `New death number`=New_death_num), filter = &#39;top&#39;, server = TRUE, options = list(pageLength = 10, autoWidth = TRUE, searching = TRUE), rownames= FALSE ) 10.4.3 更新圖片的反應函數 更新圖片的反應函數共有八個，設計大同小異，使用reactive()函數追蹤是否要將數值取log的輸入元件變化，並使用ggplot製作折線圖，ggplot的使用可參考ggplot教學。若值取log的輸入元件有改變，則重新作圖，並依照使用者的選擇決定是否要加上ggplot內建製作log圖表scale_y_log10()功能。 ## reactive plot plot_topN_data&lt;-reactive({ p&lt;-ggplot(topN_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_top==&quot;2&quot;){ p+labs(x=&quot;Date&quot;,y=&quot;Total cases (log)&quot;)+ scale_y_log10() }else{ p+labs(x=&quot;Date&quot;,y=&quot;Total cases&quot;) } } ) plot_topN_new_data&lt;-reactive({ p&lt;-ggplot(topN_new_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_top==&quot;2&quot;){ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases (log)&quot;)+ scale_y_log10() }else{ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases&quot;) } } ) plot_topN_death_data&lt;-reactive({ p&lt;-ggplot(topN_death_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_top==&quot;2&quot;){ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases (log)&quot;)+ scale_y_log10() }else{ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases&quot;) } } ) plot_topN_epi_data&lt;-reactive({ p&lt;-ggplot(topN_epi_data())+ geom_line(aes(x=nDays,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_top==&quot;2&quot;){ p+ labs(x=&quot;Number of days since 10th death&quot;,y=&quot;Total number of death (log)&quot;)+ scale_y_log10() }else{ p+ labs(x=&quot;Number of days since 10th death&quot;,y=&quot;Total number of death&quot;) } } ) plot_country_case_data&lt;-reactive({ p&lt;-ggplot(country_case_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_sel==&quot;2&quot;){ p+ labs(x=&quot;Date&quot;,y=&quot;Total cases (log)&quot;)+ scale_y_log10() #breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), #labels = trans_format(&quot;log10&quot;, math_format(10^.x)) }else{ p+ labs(x=&quot;Date&quot;,y=&quot;Total cases&quot;) } } ) plot_country_newcase_data&lt;-reactive({ p&lt;-ggplot(country_newcase_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_sel==&quot;2&quot;){ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases (log)&quot;)+ scale_y_log10() #breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), #labels = trans_format(&quot;log10&quot;, math_format(10^.x)) }else{ p+ labs(x=&quot;Date&quot;,y=&quot;Daily new cases&quot;) } } ) plot_country_death_data&lt;-reactive({ p&lt;-ggplot(country_epi_data())+ geom_line(aes(x=Date,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_sel==&quot;2&quot;){ p+ labs(x=&quot;Date&quot;,y=&quot;Total number of death (log)&quot;)+ scale_y_log10() #breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), #labels = trans_format(&quot;log10&quot;, math_format(10^.x)) }else{ p+ labs(x=&quot;Date&quot;,y=&quot;Total number of death&quot;) } } ) plot_country_epi_data&lt;-reactive({ p&lt;-ggplot(country_death_data())+ geom_line(aes(x=nDays,y=`Case number`,color=`Country/Region`))+ theme_bw() if(input$log_sel==&quot;2&quot;){ p+ labs(x=&quot;Number of days since 10th death&quot;,y=&quot;Total death (log)&quot;)+ scale_y_log10() #breaks = trans_breaks(&quot;log10&quot;, function(x) 10^x), #labels = trans_format(&quot;log10&quot;, math_format(10^.x)) }else{ p+ labs(x=&quot;Number of days since 10th death&quot;,y=&quot;Total death&quot;) } } ) 10.4.4 更新資料的反應函數 此儀表板會因輸入元件改變而須重新篩選整理的資料生成程式碼都包在獨立的反應函數內，反應函數的使用可參考反應函數章節Ch. 6.2，圖片部分主要使用dplyr套件一使用者選擇的國家進行資料篩選 (使用filter()功能)，mutate()則是應用在設定圖片國家排列順序的factor生成。 地圖資料的部分，主要是依照使用者選擇的日期區間篩選filter()並更新輸入資料，將選擇區間內的新案例數使用summarise()加總成為區間內總案例數，最後更新地圖中滑鼠滑過該區域而跳出的資訊視窗的內容，寫入lab，其中使用sprintf以及許多HTML tags做排版，有興趣的話可以自學HTML完成。 ## reactive data for plot country_case_data&lt;-reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% input$country_select &amp; Type==&quot;Total_case_num&quot;) } ) country_newcase_data&lt;-reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% input$country_select &amp; Type==&quot;New_case_num&quot;) } ) country_epi_data&lt;-reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% input$country_select &amp; Type==&quot;Total_death_num&quot;) } ) country_death_data&lt;-reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% input$country_select &amp; Type==&quot;Total_death_num&quot;) } ) topN_data&lt;- reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% TopCaseCountry[1:as.numeric(input$topN)] &amp; Type==&quot;Total_case_num&quot;) %&gt;% mutate(`Country/Region`= factor(`Country/Region`, levels = TopCaseCountry[1:as.numeric(input$topN)])) } ) topN_new_data&lt;- reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% TopNewCaseCountry[1:as.numeric(input$topN)] &amp; Type==&quot;New_case_num&quot;) %&gt;% mutate(`Country/Region`= factor(`Country/Region`, levels = TopNewCaseCountry[1:as.numeric(input$topN)])) } ) topN_death_data&lt;- reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% TopDeathCountry[1:as.numeric(input$topN)] &amp; Type==&quot;Total_death_num&quot;) %&gt;% mutate(`Country/Region`= factor(`Country/Region`, levels = TopDeathCountry[1:as.numeric(input$topN)])) } ) topN_epi_data&lt;- reactive({ covid_country_long %&gt;% filter(`Country/Region` %in% TopDeathCountry[1:as.numeric(input$topN)] &amp; Type==&quot;Total_death_num&quot;) %&gt;% mutate(`Country/Region`= factor(`Country/Region`, levels = TopDeathCountry[1:as.numeric(input$topN)])) } ) ## reactive data for map world_case_dym&lt;-reactive({ period_data&lt;-covid_country %&gt;% filter(date&lt;= lubridate::ymd(input$period[2]) &amp; date&gt;= lubridate::ymd(input$period[1]))%&gt;% group_by(`Country/Region`) %&gt;% summarise(NewCaseTotal=sum(New_case_num), NewDeathTotal=sum(New_death_num)) %&gt;% mutate(CFR=NewDeathTotal/NewCaseTotal) world_case@data &lt;- left_join(world_case@data, period_data, by = c(&quot;name&quot; = &quot;Country/Region&quot;)) world_case@data$lab &lt;- sprintf( &quot;&lt;i&gt;%s - %s&lt;/i&gt;&lt;br/&gt;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Total cases:&lt;/strong&gt; %g&lt;br/&gt;&lt;strong&gt;Total death:&lt;/strong&gt; %g&lt;br/&gt;&lt;strong&gt;CFR:&lt;/strong&gt; %g&quot;, input$period[1],input$period[2], world_case@data$name, world_case@data$NewCaseTotal, world_case@data$NewDeathTotal, round(world_case@data$CFR*100,1) ) %&gt;% lapply(htmltools::HTML) world_case }) 10.5 資料整理獨立程式碼 因提昇程式碼的易讀性 (不想讓單檔太長)以及方便未來維護，將疫情資料與地圖資料的處理獨立的R程式碼檔案dataLoad.R，若想在執行shiny APP前載入獨立的R程式碼檔案，可在app.R中使用soruce()載入。 source(&quot;dataLoad.R&quot;) 以下是獨立R程式碼檔案dataLoad.R的內容，包括將COVID-19 Data Repository by Johns Hopkins CSSE的案例數和死亡數資料匯入，原設計為寬表，轉換成長表方便後續分析，並計算每日新案例數與新死亡數，以及將案例數與死亡數合併成一張表格等，主要使用dplyr套件的各類函數，可參考dplyr教學。 地圖檔案部分，使用geojson檔案，來源為johan/world.geo.json，因國家名稱在COVID-19 Data Repository by Johns Hopkins CSSE和此地圖檔有些許出入，因此也做了人工的對應，有些國家名稱使用地圖檔為基準，有些使用COVID-19資料為基準，是全人眼與世界觀對應。 因資料整理部分與shiny app開發本身較無關，也不一定要使用這種方式整理，除上述dplyr教學外，也可參考長表轉寬表教學。 library(readr) library(tidyr) library(dplyr) library(purrr) library(leaflet) ##################################################################### # original data load and preprocessing ##################################################################### covid_case_wide&lt;- read_csv(&quot;https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv&quot;) covid_case_long&lt;-gather(covid_case_wide,date,num ,-`Province/State`,-`Country/Region`,-Lat,-Long) %&gt;% mutate(date=lubridate::mdy(date)) covid_case_long_country&lt;-covid_case_long %&gt;% group_by(`Country/Region`,date) %&gt;% summarise(Total_case_num=sum(num)) %&gt;% ungroup() %&gt;% group_by(`Country/Region`) %&gt;% arrange(`Country/Region`,date) %&gt;% mutate(New_case_num=Total_case_num-lag(Total_case_num,default = 0)) covid_death_wide&lt;- read_csv(&quot;https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv&quot;) covid_death_long&lt;-gather(covid_death_wide,date,num, -`Province/State`,-`Country/Region`,-Lat,-Long) %&gt;% mutate(date=lubridate::mdy(date)) covid_death_long_country&lt;-covid_death_long %&gt;% group_by(`Country/Region`,date) %&gt;% summarise(Total_death_num=sum(num)) %&gt;% ungroup() %&gt;% group_by(`Country/Region`) %&gt;% arrange(`Country/Region`,date) %&gt;% mutate(New_death_num=Total_death_num-lag(Total_death_num,default = 0)) ##################################################################### # case and death data merge ##################################################################### covid_country&lt;- left_join(covid_case_long_country , covid_death_long_country, by = c(&quot;Country/Region&quot;, &quot;date&quot;)) ##################################################################### # clean country name ##################################################################### covid_country$`Country/Region`&lt;- gsub(&quot;[*]&quot;,&quot;&quot;,covid_country$`Country/Region`) covid_country$`Country/Region`&lt;- gsub(&quot;US&quot;,&quot;United States of America&quot;, covid_country$`Country/Region`) covid_country$`Country/Region`&lt;- gsub(&quot;Korea, South&quot;,&quot;South Korea&quot;,covid_country$`Country/Region`) covid_country$`Country/Region`&lt;- gsub(&quot;Serbia&quot;,&quot;Republic of Serbia&quot;,covid_country$`Country/Region`) covid_country$`Country/Region`&lt;- gsub(&quot;Bahamas&quot;,&quot;The Bahamas&quot;,covid_country$`Country/Region`) ##################################################################### # generate long data format ##################################################################### covid_country_long&lt;- gather(covid_country,num_type,num, -`Country/Region`,-date) %&gt;% ungroup() %&gt;% rename(Date=date, `Case number`=num, Type=num_type) ##################################################################### # days after 10th death ##################################################################### covid_country_long&lt;-covid_country_long %&gt;% mutate(nDays=ifelse(Type==&quot;Total_death_num&quot; &amp;`Case number`&gt;=10,1,0)) %&gt;% group_by(`Country/Region`,Type) %&gt;% arrange(`Country/Region`,Type,Date) %&gt;% mutate(nDays=cumsum(nDays)) %&gt;% ungroup() ##################################################################### # map data ##################################################################### # from https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json world_case &lt;- geojsonio::geojson_read(&quot;countries.geo.json&quot;, what = &quot;sp&quot;) ## name world_case@data$name&lt;- gsub(&quot;Czech Republic&quot;,&quot;Czechia&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;Myanmar&quot;,&quot;Burma&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;United Republic of Tanzania&quot;,&quot;Tanzania&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;Democratic Republic of the Congo&quot;,&quot;Congo (Kinshasa)&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;Republic of the Congo&quot;,&quot;Congo (Brazzaville)&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;Guinea Bissau&quot;,&quot;Guinea-Bissau&quot;,world_case@data$name) world_case@data$name&lt;- gsub(&quot;Macedonia&quot;,&quot;North Macedonia&quot;,world_case@data$name) ## color bins &lt;- c(0, 100,1000,10000,100000, Inf) pal &lt;- colorBin(&quot;YlOrRd&quot;, bins = bins) ##################################################################### # top n country ##################################################################### TopCaseCountry&lt;-covid_country_long %&gt;% filter(Date==max(Date) &amp; Type==&quot;Total_case_num&quot;) %&gt;% arrange(desc(`Case number`)) %&gt;% pull(`Country/Region`) TopNewCaseCountry&lt;-covid_country_long %&gt;% filter(Date==max(Date) &amp; Type==&quot;New_case_num&quot;) %&gt;% arrange(desc(`Case number`)) %&gt;% pull(`Country/Region`) TopDeathCountry&lt;-covid_country_long %&gt;% filter(Date==max(Date) &amp; Type==&quot;Total_death_num&quot;) %&gt;% arrange(desc(`Case number`)) %&gt;% pull(`Country/Region`) TopCFRCountry&lt;-covid_country_long %&gt;% filter(Date==max(Date) &amp; Type==&quot;Total_CFR_num&quot;) %&gt;% arrange(desc(`Case number`)) %&gt;% pull(`Country/Region`) 以上即為2019年末至2020年的新冠肺炎 (COVID-19)流行趨勢儀表板的Shiny App撰寫說明，程式也已上版，可由 Demo網址查看。 References "],
["js.html", "Ch 11 客製化使用者介面 11.1 D3.js 11.2 JavaScript", " Ch 11 客製化使用者介面 撰寫中 11.1 D3.js 11.2 JavaScript "],
["test.html", "Ch 12 介面與效能測試 12.1 介面測試 12.2 效能測試 12.3 參考資料", " Ch 12 介面與效能測試 撰寫中 12.1 介面測試 shinytest library(devtools) install_github(&quot;rstudio/shinytest&quot;) shinytest::installDependencies() library(shinytest) # Launch the target app (replace with the correct path) recordTest(&quot;path/to/app&quot;) 12.2 效能測試 Shiny App的效能測試通常是基準測試 Benchmark、效能分析 Analyze、建議解決方案 Recommend、程式最佳化 Optimize四個步驟的循環 ( 參考資料 ): 基準測試 Benchmark: 以一般使用者的使用方式測試系統，如果感覺不夠快，就進到下一步。若想測試多人同時使用的情境，可使用shinyloadtest套件(Dipert, Schloerke, and Borges 2020)進行測試 效能分析 Analyze: 利用工具 (如profvis (Chang, Luraschi, and Mastny 2019))計算每一步所花時間，找到最花時間的步驟，可能是讀檔、計算、網路連線等 建議解決方案 Recommend: 針對最花時間的步驟，研擬解決的辦法，包括限制使用者的行為或是最佳化 (Optimize)程式 程式最佳化 Optimize: 需要的資料不要每次啟動應用程式都重新下載並處理，可先完成，若資料很大，建議先做預處理，不要在Shiny App中讀取大檔案 注意dplyr::group_by()的使用順序，盡量在filter之後 若需讀格式單純的檔案，csv比rds快 若Shiny App中有一些圖是使用者會重複得到的輸出結果，可考慮用plotCache()存快取 因放在server中的程式碼是每個session都會執行一次， 完成測試後，就能將Shiny App正式部屬(Deploy)上線。 12.2.1 基準測試 Benchmark run app record playback analyze 要開兩個R session，第一個session跑Shiny App，第二個session跑shinyloadtest 12.2.2 效能分析 Analyze profiling 花時間的程式碼，如讀檔，grouping，aggregation等，可以在Shiny App執行前就將檔案準備好，例如把可以先跑的程式碼寫在獨立的R Script中，用排程的方式已固定的頻率重新執行，以更新資料 12.2.3 程式最佳化 Optimize plot caching 畫圖很慢 有一些圖是蠻多使用者在使用Shiny App的時候會得到的輸出結果 renderCachedPlot({ },cacheKeyExpr = { }) renderPlot() shinyloadtest profvis Async shinyloadtest -&gt; profvis -&gt; Optimize -&gt; Deploy shinyloadtest 12.3 參考資料 Getting started with shinytest Shiny in Production Make Shiny Fast References "],
["author.html", "作者資訊", " 作者資訊 曾意儒 Yi-Ju Tseng 個人網站 長庚大學 資訊管理學系 副教授 Lab: 數位健康實驗室 歡迎提供建議與回饋 "],
["-8.html", "參考資料", " 參考資料 How to Start Shiny tutorial Dynamic Dashboards with Shiny Mastering Shiny https://resources.rstudio.com/shiny-2/shiny-cheat-sheet https://resources.rstudio.com/shiny-2/shiny-1-1-0-scaling-shiny-with-async https://resources.rstudio.com/shiny-2/make-shiny-fast-by-doing-as-little-work-as-possible-alan-dipert "]
]
